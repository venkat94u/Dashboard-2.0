<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mobile Orderflow — Balanced Institutional Dashboard</title>
<style>
:root{
  --bg:#071226; --card:#0f2030; --muted:#9fb0c8; --accent:#00d084;
  --buy:#66ffb2; --sell:#ff7b7b; --text:#e6f0fb;
}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:var(--bg);color:var(--text)}
.wrap{max-width:980px;margin:8px auto;padding:10px}
.header{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap}
.title{font-size:16px;margin:0}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
select,input,button{padding:8px;border-radius:8px;border:0;background:#081726;color:var(--text);font-size:13px}
button{cursor:pointer}
.card{background:var(--card);padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.45);margin-top:10px}
.row{display:flex;justify-content:space-between;align-items:center}
.muted{color:var(--muted);font-size:12px}
.grid{display:grid;grid-template-columns:1fr 340px;gap:10px;margin-top:10px}
@media (max-width:900px){ .grid{grid-template-columns:1fr} .header{flex-direction:column;align-items:flex-start} }
.top-stats{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
.stat{padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
.trade-list{height:220px;overflow:auto;padding:6px;margin-top:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
.trade{display:flex;justify-content:space-between;padding:6px;border-radius:6px;margin-bottom:4px;font-size:13px}
.buy{color:var(--buy)}
.sell{color:var(--sell)}
.small{font-size:12px;color:var(--muted)}
.table{font-size:13px}
.badge{display:inline-block;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.02);font-size:13px}
.alertBox{padding:10px;border-radius:8px;margin-bottom:8px}
.swing-high{background:rgba(255,90,90,0.06);border:1px solid rgba(255,90,90,0.14);color:#ffb3b3}
.swing-low{background:rgba(0,210,130,0.04);border:1px solid rgba(0,210,130,0.12);color:#bfffe0}
.small-input{width:80px}
.footer-note{font-size:12px;color:var(--muted);margin-top:8px}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div>
      <h1 class="title">Orderflow Analyst — Balanced (Mobile)</h1>
      <div class="small muted">Option C — Microstructure swing (sweep + delta flip) + confirmations</div>
    </div>
    <div class="controls">
      <label class="small muted">Symbol</label>
      <select id="symbol">
        <option>BTCUSDT</option><option>ETHUSDT</option><option>SOLUSDT</option>
      </select>
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" style="display:none">Disconnect</button>
      <span id="status" class="muted">Disconnected</span>
    </div>
  </div>

  <!-- Calibration & top stats -->
  <div class="card">
    <div class="row">
      <div>
        <div id="swingPanelContainer"></div>
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:6px">
          <div class="stat"><div class="small muted">Calibration</div><div id="calib" class="small">Not running</div></div>
          <div class="stat"><div class="small muted">Cumulative Delta</div><div id="cumlDelta">0</div></div>
          <div class="stat"><div class="small muted">Buy / Sell Vol</div><div id="vols">0 / 0</div></div>
          <div class="stat"><div class="small muted">Strength</div><div id="strength">—</div></div>
        </div>
      </div>
      <div style="text-align:right">
        <div class="small muted">Tune</div>
        <div style="display:flex;gap:6px;align-items:center;justify-content:flex-end;margin-top:6px">
          <label class="small muted">WallSize</label><input id="wallSize" class="small-input" value="50" />
          <label class="small muted">Burst</label><input id="burstCnt" class="small-input" value="8" />
        </div>
      </div>
    </div>
  </div>

  <div class="grid">
    <!-- Left column -->
    <div>
      <div class="card">
        <div class="small muted">Sweep & Divergence</div>
        <div style="margin-top:8px" id="sweepInfo">Sweep: — | Divergence: —</div>
      </div>

      <div class="card">
        <div class="small muted">Market Order Bursts</div>
        <div style="display:flex;gap:12px;margin-top:8px">
          <div><div class="small muted">Buy Burst</div><div id="buyBurst" class="big">0</div></div>
          <div><div class="small muted">Sell Burst</div><div id="sellBurst" class="big">0</div></div>
          <div><div class="small muted">Aggressive</div><div id="aggr" class="big">—</div></div>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <div class="small muted">Recent Trades (live)</div>
          <div class="small muted">max 100</div>
        </div>
        <div id="trades" class="trade-list"></div>
      </div>

      <div class="card">
        <div class="small muted">Logs</div>
        <div id="logs" style="max-height:120px;overflow:auto;margin-top:8px" class="small"></div>
      </div>
    </div>

    <!-- Right column -->
    <div>
      <div class="card">
        <div class="small muted">Top-of-book</div>
        <div style="display:flex;justify-content:space-between;margin-top:8px">
          <div><div class="small muted">Best Bid</div><div id="bestBid" class="big">-</div></div>
          <div><div class="small muted">Best Ask</div><div id="bestAsk" class="big">-</div></div>
        </div>
      </div>

      <div class="card">
        <div class="small muted">Wall Clusters</div>
        <div style="margin-top:8px">
          <div class="small muted">Buy clusters: <span id="buyCluster">0</span></div>
          <div class="small muted">Sell clusters: <span id="sellCluster">0</span></div>
          <div style="margin-top:8px"><div class="small muted">Top buy walls</div><div id="topBids" class="table"></div></div>
          <div style="margin-top:8px"><div class="small muted">Top sell walls</div><div id="topAsks" class="table"></div></div>
        </div>
      </div>

      <div class="card" style="margin-top:10px">
        <div class="small muted">Controls</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="clearBtn">Clear State</button>
          <button id="downloadBtn">Download L2 CSV</button>
        </div>
        <div class="footer-note">Auto reconnect enabled. Calibration: 180s default.</div>
      </div>
    </div>
  </div>

  <!-- full L2 walls bottom -->
  <div class="card">
    <div class="small muted">L2 Walls (depth20)</div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:8px">
      <div>
        <div class="small muted">BIDS (price — qty)</div>
        <div id="buyWalls" class="table" style="max-height:240px;overflow:auto;margin-top:6px"></div>
      </div>
      <div>
        <div class="small muted">ASKS (price — qty)</div>
        <div id="sellWalls" class="table" style="max-height:240px;overflow:auto;margin-top:6px"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   Balanced Mobile Dashboard
   - Binance futures combined streams:
     wss://fstream.binance.com/stream?streams=<symbol>@trade/<symbol>@depth20@100ms
   - Option C: balanced (calibration + confirmations)
   ========================= */

// ------------- CONFIG -------------
const CALIBRATION_SECONDS = 180; // default calibration period (3 minutes)
const WALL_SIZE_DEFAULT = 50;    // default wall size (tune per symbol)
const BURST_THRESHOLD_DEFAULT = 8; // aggressive trades threshold in window
const MAX_TRADES_DISPLAY = 100;  // limit displayed trades for performance
const BURST_WINDOW_MS = 2500;    // burst window
const DIV_WINDOW = 12;           // history length for divergence detection

// ------------- STATE -------------
let ws = null;
let running = false;
let symbol = document.getElementById('symbol').value.toLowerCase();

let buyVol = 0, sellVol = 0, cumDelta = 0;
let recentTrades = []; // {price, qty, side, ts}
let bids = [], asks = [];
let lastBestBid = null, lastBestAsk = null;
let lastHigh = null, lastLow = null;
let lastPrice = null, lastPrice2 = null;
let lastDeltaSide = null;
let lastOrderbook = null;
let calibrationStartedAt = null;
let calibrated = false;

// data for confluence (1m/5m) aggregated locally
let agg1m = [], agg5m = []; // arrays of {tStart, buyVol, sellVol, delta}

// UI refs
const statusEl = document.getElementById('status');
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const tradesEl = document.getElementById('trades');
const topBidsEl = document.getElementById('topBids');
const topAsksEl = document.getElementById('topAsks');
const buyWallsEl = document.getElementById('buyWalls');
const sellWallsEl = document.getElementById('sellWalls');
const bestBidEl = document.getElementById('bestBid');
const bestAskEl = document.getElementById('bestAsk');
const buyClusterEl = document.getElementById('buyCluster');
const sellClusterEl = document.getElementById('sellCluster');
const volsEl = document.getElementById('vols');
const cumlEl = document.getElementById('cumlDelta');
const strengthEl = document.getElementById('strength');
const swingPanelContainer = document.getElementById('swingPanelContainer');
const sweepInfoEl = document.getElementById('sweepInfo');
const divergenceInfoEl = document.getElementById('divergenceInfo');
const buyBurstEl = document.getElementById('buyBurst');
const sellBurstEl = document.getElementById('sellBurst');
const aggrEl = document.getElementById('aggr');
const logsEl = document.getElementById('logs');
const calibEl = document.getElementById('calib');

const wallSizeInput = document.getElementById('wallSize');
const burstCntInput = document.getElementById('burstCnt');
const clearBtn = document.getElementById('clearBtn');
const downloadBtn = document.getElementById('downloadBtn');

// helpers
const f = v => (v === undefined || v === null) ? 0 : parseFloat(v);
const now = () => Date.now();

// logs
function log(msg){ const d = document.createElement('div'); d.innerText = `[${(new Date()).toLocaleTimeString()}] ${msg}`; logsEl.prepend(d); if(logsEl.childElementCount>200) logsEl.removeChild(logsEl.lastChild); }

// UI updates (throttled)
let uiTimer = null;
function scheduleUI(){ if(uiTimer) return; uiTimer = setTimeout(()=>{ uiTimer=null; updateUI(); }, 120); }

// update UI
function updateUI(){
  volsEl.innerText = `${buyVol.toFixed(6)} / ${sellVol.toFixed(6)}`;
  cumlEl.innerText = cumDelta.toFixed(6);

  // best bid/ask
  const bidsByPrice = bids.slice().map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>b[0]-a[0]);
  const asksByPrice = asks.slice().map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>a[0]-b[0]);
  bestBidEl.innerText = bidsByPrice.length ? bidsByPrice[0][0] : '-';
  bestAskEl.innerText = asksByPrice.length ? asksByPrice[0][0] : '-';

  // top walls
  const topB = bidsByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  const topA = asksByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  topBidsEl.innerHTML = topB.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  topAsksEl.innerHTML = topA.map(it=>`${it[0]} — ${it[1]}`).join('<br>');

  buyWallsEl.innerHTML = bidsByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  sellWallsEl.innerHTML = asksByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');

  // clusters
  const wallSize = getParamInt(wallSizeInput, WALL_SIZE_DEFAULT);
  const buyClusterCount = topB.filter(it=>it[1] > wallSize).length;
  const sellClusterCount = topA.filter(it=>it[1] > wallSize).length;
  buyClusterEl.innerText = String(buyClusterCount);
  sellClusterEl.innerText = String(sellClusterCount);

  // bursts & agg
  const windowStart = now() - BURST_WINDOW_MS;
  const recentWindowTrades = recentTrades.filter(r=>r.ts >= windowStart);
  const buyAgg = recentWindowTrades.filter(r=>r.side==='buy').length;
  const sellAgg = recentWindowTrades.filter(r=>r.side==='sell').length;
  buyBurstEl.innerText = String(buyAgg);
  sellBurstEl.innerText = String(sellAgg);
  aggrEl.innerText = (buyAgg>sellAgg)?'BUY':(sellAgg>buyAgg)?'SELL':'—';

  // strength measure (simple ratio)
  const ratio = buyVol / Math.max(sellVol, 1);
  if(ratio > 1.6) strengthEl.innerText = 'BUYERS DOMINANT';
  else if(ratio > 1.2) strengthEl.innerText = 'Buyers Strong';
  else if(ratio < 0.6) strengthEl.innerText = 'Sellers Strong';
  else if(ratio < 0.4) strengthEl.innerText = 'SELLERS DOMINANT';
  else strengthEl.innerText = 'Balanced';

  // trades list trimmed
  while(tradesEl.childElementCount > MAX_TRADES_DISPLAY) tradesEl.removeChild(tradesEl.lastChild);
}

// param helper
function getParamInt(el, fallback){ const v = parseFloat(el.value); return isFinite(v) ? v : fallback; }

// clear state
function clearAll(){
  buyVol=0; sellVol=0; cumDelta=0;
  recentTrades=[]; bids=[]; asks=[];
  lastBestBid=null; lastBestAsk=null;
  lastHigh=null; lastLow=null;
  lastPrice=null; lastPrice2=null; lastDeltaSide=null;
  lastOrderbook=null;
  agg1m=[]; agg5m=[];
  calibrated=false; calibrationStartedAt=null;
  swingPanelContainer.innerHTML='';
  logsEl.innerHTML='';
  updateUI();
  log('State cleared');
}

// ---------- Orderbook helpers ----------
function handleDepthPayload(d){
  // unify structure: d.b, d.a arrays
  if(!d) return;
  if(d.b) bids = d.b.slice();
  if(d.a) asks = d.a.slice();
  // update orderbook snapshot reference
  lastOrderbook = { bids: bids.slice(), asks: asks.slice() };
  // track bests & highs/lows
  const bestB = bids.length ? f(bids[0][0]) : null;
  const bestA = asks.length ? f(asks[0][0]) : null;
  if(bestB !== null){
    if(lastBestBid !== null && bestB < lastBestBid) log(`BestBid collapsed ${lastBestBid} → ${bestB}`);
    lastBestBid = bestB;
    if(lastLow === null || bestB < lastLow) lastLow = bestB;
  }
  if(bestA !== null){
    if(lastBestAsk !== null && bestA > lastBestAsk) log(`BestAsk expanded ${lastBestAsk} → ${bestA}`);
    lastBestAsk = bestA;
    if(lastHigh === null || bestA > lastHigh) lastHigh = bestA;
  }
  scheduleUI();
  detectClustersAndSwing(); // lightweight detectors on depth update
}

// ---------- Trades handler ----------
function handleTradePayload(t){
  // unify: t.p (price) t.q (qty) t.m (isMaker)
  const price = f(t.p);
  const qty = f(t.q);
  const isMaker = !!t.m;
  const side = isMaker ? 'sell' : 'buy'; // Binance: m=true means maker (taker was sell)
  const ts = now();

  // record
  recentTrades.unshift({price, qty, side, ts});
  if(recentTrades.length > 1000) recentTrades.pop();

  // update volumes & delta
  if(side === 'buy'){ buyVol += qty; cumDelta += qty; }
  else { sellVol += qty; cumDelta -= qty; }

  // update price history
  lastPrice2 = lastPrice;
  lastPrice = price;

  // aggregate for 1m/5m confluence
  aggregateConfluence(price, qty, side, ts);

  // display trade (prepend)
  const el = document.createElement('div');
  el.className = 'trade ' + (side==='buy'?'buy':'sell');
  el.innerHTML = `<div>${side.toUpperCase()} <span style="opacity:0.7">${price}</span></div><div>${qty}</div>`;
  tradesEl.prepend(el);
  if(tradesEl.childElementCount > MAX_TRADES_DISPLAY) tradesEl.removeChild(tradesEl.lastChild);

  // perform swing detection (core)
  detectSwing(price, cumDelta);

  scheduleUI();
}

// ------------- Aggregation for 1m/5m confluence -------------
function aggregateConfluence(price, qty, side, ts){
  const minute = Math.floor(ts / 60000) * 60000; // 1m bucket start
  const fiveMinute = Math.floor(ts / (5*60000)) * (5*60000);
  // 1m
  let b1 = agg1m.length && agg1m[agg1m.length-1].tStart === minute ? agg1m[agg1m.length-1] : null;
  if(!b1){ b1 = {tStart: minute, buyVol:0, sellVol:0, delta:0}; agg1m.push(b1); if(agg1m.length>50) agg1m.shift(); }
  if(side==='buy'){ b1.buyVol += qty; b1.delta += qty; } else { b1.sellVol += qty; b1.delta -= qty; }
  // 5m
  let b5 = agg5m.length && agg5m[agg5m.length-1].tStart === fiveMinute ? agg5m[agg5m.length-1] : null;
  if(!b5){ b5 = {tStart: fiveMinute, buyVol:0, sellVol:0, delta:0}; agg5m.push(b5); if(agg5m.length>50) agg5m.shift(); }
  if(side==='buy'){ b5.buyVol += qty; b5.delta += qty; } else { b5.sellVol += qty; b5.delta -= qty; }
}

// ------------- Detectors: clusters, sweep, divergence -------------
function detectClustersAndSwing(){
  const wallSize = getParamInt(wallSizeInput, WALL_SIZE_DEFAULT);
  // top 12
  const bidsByPrice = bids.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>b[0]-a[0]).slice(0,12);
  const asksByPrice = asks.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>a[0]-b[0]).slice(0,12);
  // clusters
  const buyClusterCount = bidsByPrice.filter(it=>it[1] > wallSize).length;
  const sellClusterCount = asksByPrice.filter(it=>it[1] > wallSize).length;
  buyClusterEl.innerText = String(buyClusterCount);
  sellClusterEl.innerText = String(sellClusterCount);
  topBidsEl.innerHTML = bidsByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  topAsksEl.innerHTML = asksByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  // sweep detection (micro)
  const sweepHigh = lastBestAsk !== null && lastBestAsk > (lastHigh || 0) * 0.999 && (lastHigh !== null);
  const sweepLow  = lastBestBid !== null && lastBestBid < (lastLow || Infinity) * 1.001 && (lastLow !== null);
  sweepInfoEl.innerText = `SweepHigh:${sweepHigh ? 'YES' : 'no'}  SweepLow:${sweepLow ? 'YES' : 'no'}`;
  // divergence (price HH vs delta LH)
  const divergence = detectDeltaDivergence();
  divergenceInfoEl.innerText = divergence ? divergence : '—';
}

// delta divergence detection (simple)
function detectDeltaDivergence(){
  if(agg1m.length < 3 || agg5m.length < 2) return null;
  const recent = agg1m.slice(-DIV_WINDOW);
  if(recent.length < 3) return null;
  const prices = recent.map(r => r.delta); // using delta as proxy for delta trend
  const first = prices[0], last = prices[prices.length-1];
  const high = Math.max(...prices), low = Math.min(...prices);
  if(high > first && last < high) return 'bear';
  if(low < first && last > low) return 'bull';
  return null;
}

// ------------- Swing engine (2 mandatory checks + 3 optional) -------------
function wallShiftDetected(ob){
  if(!lastOrderbook || !ob) return false;
  const oldBuy = lastOrderbook.bids[0]?.[1] ?? 0;
  const newBuy = ob.bids[0]?.[1] ?? 0;
  const oldSell = lastOrderbook.asks[0]?.[1] ?? 0;
  const newSell = ob.asks[0]?.[1] ?? 0;
  return (newBuy > oldBuy * 1.4) || (newSell > oldSell * 1.4);
}
function fastReaction(price){
  if(!lastPrice || !lastPrice2) return false;
  // quick heuristic: if price reversed > 1.5x last step size
  return Math.abs(price - lastPrice2) > (Math.abs(lastPrice - lastPrice2) * 1.5);
}
function rateSwing(st){
  const flags = [st.sweep, st.deltaFlip, st.momentum, st.wallShift, st.reactionSpeed];
  const stars = flags.filter(v => v === 'YES').length;
  return '★'.repeat(stars) + '☆'.repeat(5 - stars);
}
function showSwingPanel(type, price, st){
  const color = type === 'HIGH' ? '#ff4444' : '#00ff88';
  const title = type === 'HIGH' ? 'SWING HIGH' : 'SWING LOW';
  const stars = rateSwing(st);
  const html = `
    <div class="alertBox ${type==='HIGH' ? 'swing-high' : 'swing-low'}">
      <strong style="color:${color};font-size:15px">${title} @ ${price}</strong><br><br>
      • Liquidity Sweep: <b>${st.sweep}</b><br>
      • Delta Flip: <b>${st.deltaFlip}</b><br>
      • Momentum: <b>${st.momentum}</b><br>
      • Wall Shift: <b>${st.wallShift}</b><br>
      • Reaction Speed: <b>${st.reactionSpeed}</b><br>
      <hr>
      <b>Swing Rating: ${stars}</b>
    </div>
  `;
  swingPanelContainer.innerHTML = html + swingPanelContainer.innerHTML;
  log(`${title} @ ${price} | ${stars}`);
}

// core detectSwing — call from trade handler
function detectSwing(price, delta){
  const deltaSide = delta > 0 ? 'buy' : 'sell';
  const deltaFlipToBuy = lastDeltaSide === 'sell' && deltaSide === 'buy';
  const deltaFlipToSell = lastDeltaSide === 'buy' && deltaSide === 'sell';

  const sweepHigh = (lastHigh !== null) && (price > lastHigh);
  const sweepLow  = (lastLow !== null) && (price < lastLow);

  const momentum = Math.abs(delta) > 20; // adjustable threshold
  const wallShift = wallShiftDetected(lastOrderbook);
  const reaction = fastReaction(price);

  const swingStatus = {
    sweep: (sweepHigh || sweepLow) ? 'YES' : 'NO',
    deltaFlip: (deltaFlipToBuy || deltaFlipToSell) ? 'YES' : 'NO',
    momentum: momentum ? 'YES' : 'NO',
    wallShift: wallShift ? 'YES' : 'NO',
    reactionSpeed: reaction ? 'YES' : 'NO'
  };

  // FIRE only when both mandatory conditions meet:
  if(sweepHigh && deltaFlipToSell){
    showSwingPanel('HIGH', price, swingStatus);
  }
  if(sweepLow && deltaFlipToBuy){
    showSwingPanel('LOW', price, swingStatus);
  }

  // update memory
  lastDeltaSide = deltaSide;
  if(lastHigh === null || price > lastHigh) lastHigh = price;
  if(lastLow === null || price < lastLow) lastLow = price;
}

// ---------- Connect / disconnect / WS handling ----------
connectBtn.addEventListener('click', () => {
  if(running) return;
  symbol = document.getElementById('symbol').value.trim().toLowerCase();
  const stream = `${symbol}@trade/${symbol}@depth20@100ms`;
  const url = `wss://fstream.binance.com/stream?streams=${stream}`;
  ws = new WebSocket(url);
  statusEl.innerText = 'Connecting...';
  ws.onopen = ()=>{ statusEl.innerText='Connected'; running=true; connectBtn.style.display='none'; disconnectBtn.style.display='inline-block'; log('WS open'); startCalibration(); };
  ws.onmessage = ev => {
    try {
      const msg = JSON.parse(ev.data);
      const payload = msg.data || msg; // sometimes direct
      if(!payload) return;
      // trade event detection
      if(payload.e === 'trade' || payload.e === 'aggTrade' || payload.p){
        // unify schema (some messages are nested)
        const trade = payload.e ? payload : payload.data;
        handleTradePayload(trade);
      } else if(payload.b || payload.a){
        // depth payload
        handleDepthPayload(payload);
      } else if(Array.isArray(payload.b) || Array.isArray(payload.a)){
        handleDepthPayload(payload);
      }
    } catch(e){ console.warn('ws parse', e); }
  };
  ws.onclose = ()=>{ statusEl.innerText='Disconnected'; running=false; connectBtn.style.display='inline-block'; disconnectBtn.style.display='none'; log('WS closed'); stopCalibration(); };
  ws.onerror = (e)=>{ statusEl.innerText='WS error'; log('WS error'); console.error(e); };
});

// manual disconnect
disconnectBtn.addEventListener('click', ()=>{ if(ws) ws.close(); ws=null; running=false; statusEl.innerText='Disconnected'; connectBtn.style.display='inline-block'; disconnectBtn.style.display='none'; stopCalibration(); });

// clear & download
clearBtn.addEventListener('click', clearAll);
downloadBtn.addEventListener('click', ()=>{
  const rows = ['side,price,qty'];
  bids.forEach(b=>rows.push(`bid,${b[0]},${b[1]}`));
  asks.forEach(a=>rows.push(`ask,${a[0]},${a[1]}`));
  const blob = new Blob([rows.join('\n')], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download=`${symbol}_l2_snapshot.csv`; a.click(); URL.revokeObjectURL(url);
});

// ---------------- Calibration logic ----------------
function startCalibration(){
  calibrationStartedAt = now();
  calibrated = false;
  calibEl.innerText = `Calibrating… ${formatSecondsRemaining(CALIBRATION_SECONDS)}`;
  const interval = setInterval(()=>{
    if(!calibrationStartedAt){ clearInterval(interval); return;}
    const elapsed = Math.floor((now() - calibrationStartedAt) / 1000);
    const remaining = CALIBRATION_SECONDS - elapsed;
    if(remaining <= 0){
      calibrated = true;
      calibEl.innerText = 'READY ✓';
      clearInterval(interval);
      log('Calibration complete — engine ready');
    } else {
      calibEl.innerText = `Calibrating… ${remaining}s`;
    }
  }, 800);
}
function stopCalibration(){ calibrationStartedAt = null; calibEl.innerText = 'Not running'; calibrated = false; }

// helper
function formatSecondsRemaining(s){ return `${s}s`; }

// initial setup
clearAll();
updateUI();
log('Dashboard ready. Click Connect.');

// lightweight auto-ui update loop to keep display smooth
setInterval(()=>{ scheduleUI(); }, 1000);

</script>
</body>
</html>
